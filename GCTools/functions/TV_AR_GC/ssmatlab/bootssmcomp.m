
function [Compstar,ferror] = bootssmcomp(y,X,Z,G,W,T,H,beta,str,nboot,comp)
%**************************************************************************
%**************************************************************************
%        This function computes bootstrapped components of a time series 
%        generated by the state space model:
%
%        y_t = X_t*beta + Z_t*alpha_t + G_t*epsilon_t
%        alpha_{t+1}= W_t*beta + T_t*alpha_t + H_t*epsilon_t
%
%        where epsilon_t is (0,sigma^2I),
%
%        with initial state
%
%        alpha_1= c + W_0*beta + a_1 + A_1*delta
%
%        where c is (0,Omega) and delta is (0,kI) (diffuse). A single
%        collapse is applied to get rid of the diffuse component.
%
%        INPUTS:
%        y    : an (n*p x nboot) matrix of observations;
%               nboot denotes the number of bootstrapped samples
%        X    : an (n*p x nbeta) matrix containing the X_t matrices; 
%               an (p x nbeta) if it is time invariant;
%               it can be []
%        Z    : an (n*p x nalpha) matrix containing the Z_t matrices;
%               an (p x nalpha) matrix if it is time invariant
%        G    : an (n*p x nepsilon) matrix containing the G_t matrices;
%               an (p x nepsilon) matrix if it is time invariant
%        W    : an (n*nalpha x nbeta) matrix containing the W_t matrices;
%               an (nalpha x nbeta) matrix if it is time invariant;
%               it can be []
%        T    : an (n*nalpha x nalpha) matrix containing the T_t matrices;
%               an (nalpha x nalpha) matrix if it time invariant
%        H    : an (n*nalpha x nepsilon) matrix containing the H_t matrices;
%               an (nalpha x nepsilon) if it is time invariant
%        beta : an (nbeta x 1) vector containing  the estimated regression
%               parameters. It can be empty
%        str  : structure containing model information
%        nboot: number of bootstraps
%        comp : logical array index, used to specify which elements of the 
%               smoothed states are to be output
%               Alternatively, in the case of a univariate unobserved
%               components model selected component can specified by one of the 
%               strings given below, or a cell array, if more bootstrapped
%               components should be computed. The order of components in
%               the cell array does not play any role.
%               Allowed strings for structural time series (STS) model:
%                    'level'- trend component
%                    'slope'- slope component
%                    'seas' - seasonal component
%                    'cycle'- cycle component
%                    'ar'   - AR component
%               Examples:
%                    comp = 'level'
%                    comp = {'level','cycle'}
%               Allowed strings corresponding to the ARIMA model based
%               (AMB) approach:
%                    'trendcycle'- trend-cycle component
%                         'trend'- trend component
%                         'cycle'- cycle component
%                         'seas' - seasonal component 
%                         'tran' - transitory component
%               Examples:
%                    comp = 'trendcycle'
%                    comp = {'trend','seas'}
%
%        OUTPUT:
%        Compstar: an (n-t1+1) x scomp x nboot matrix of the chosen bootstrapped 
%                  components, where 
%                  scomp is the number of these components and
%                  t1 is the time point of the collapse of the diffuse
%                  Kalman filter
%        ferror  : flag for errors
%*************************************************************************
% Written by Martyna Marczak, 23.01.2012
% Department of Economics (520G) 
% University of Hohenheim
% Schloss, Museumsfluegel
% 70593 Stuttgart, Germany
% Phone: + 49 711 459 23823
% E-mail: marczak@uni-hohenheim.de
%*************************************************************************
%*************************************************************************

ferror=0;
ins = str.ins;
ii = str.i;

if isfield(str,'stra')
    freq = str.stra.freq;
else
    freq = str.freq;
end

% Check for inconsistencies
if ~islogical(comp) && ~ischar(comp)  && ~iscell(comp)
    error('comp must be either a logical vector or a string/cell array')
end


% Transform a string to a cell array
if ischar(comp)
   comp = {comp};
end

% Check for the existence of a univariate unobserved components model
% by checking the existence of trend only

if iscell(comp)
    if (~any(strcmpi('trend',fieldnames(str)))) && (~any(strcmpi('compcd',fieldnames(str))))
       error('The model is not a univariate unobserved components model. Use logical array to indicate components')
    end
end

% Check the existence of components in the model under consideration

if iscell(comp)
  
   if isfield(str,'trend')
     
      % STS approach
      if (any(strcmpi('level',comp)) && (str.trend==0 || str.trend==-1))
          error('Level is not included in the state vector')    
      end

      if (any(strcmpi('slope',comp)) && (str.slope==0 || str.slope==-1))
         error('Slope is not included in the state vector')    
      end

      if (any(strcmpi('seas',comp)) && str.seas==0)
         error('Seasonal is not included in the state vector')   
      end

      if (any(strcmpi('cycle',comp)) && str.cycle==0)
         error('Cycle is not included in the state vector')    
      end

      if (any(strcmpi('ar',comp)) && str.arp==0)
         error('AR is not included in the state vector')   
      end
      
      if str.trend == 1         % stochastic level
         level = 1;
      elseif str.trend == 2     % Butterworth tangent
         nlev = 2; 
         level = ones(1,nlev);
      else level = [];          % no or constant level
      end

      if str.slope == 1         % stochastic slope
         slope = 2;
      else slope = [];          % no or constant slope
      end

      if str.seas ~= 0
         if str.seas == 4
            nseas = freq;
         else nseas = freq-1;   % Butterworth tangent seasonality
         end
         seas = repmat(3,1,nseas);
      else seas = [];           % no seasonals
      end

      if str.cycle ~= 0
         cycle = [4 4];
      else cycle = [];          % no cycle
      end


      if str.arp ~= 0
         nar = str.arp;
         ar = repmat(5,1,nar); 
      else ar = [];             % no AR component
      end

      compall = [level slope seas cycle ar];

   else
       
      % AMB approach
      if any(strcmpi('trendcycle',comp))
          if  ~isfield(str,'compcd') || isfield(str,'compf')
             error('Trend-cycle is not included in the state vector')  
          end
      end
      
      if any(strcmpi('trend',comp)) 
          if ~isfield(str,'compcd') && ~isfield(str,'compf')
              error('Trend is not included in the state vector') 
          end
      end
      
      if any(strcmpi('cycle',comp))
          if ~isfield(str,'compcd') && ~isfield(str,'compf')
              error('Cycle is not included in the state vector')    
          end
      end
      
      if any(strcmpi('seas',comp)) 
          if ~isfield(str,'compcd')
              error('Seasonal is not included in the state vector')   
          end
      end
      
      if any(strcmpi('tran',comp)) 
          if ~isfield(str,'compcd') || (isfield(str,'compcd') && isempty(str.compcd.rt))
             error('Transitory component is not included in the state vector')
          end
      end
      
      if  isfield(str,'compcd') && ~isfield(str,'compf')
          ptden = str.compcd.ptden;
          np = length(ptden);
          trendcycle = ones(1,np);
      else
          trendcycle = [];
      end
      
      
      if isfield(str,'compcd')
          stden = str.compcd.stden; 
          ns = length(stden);
          seas = ones(1,ns)*4;
      else
          seas = []; ns=0;
      end
      
      
      if isfield(str,'compcd') && ~isempty(str.compcd.rt)
          rt = str.compcd.rt;
          nr = length(rt);
          tran = ones(1,nr)*5;
      else
          tran = []; nr=0;
      end
      
       
      if isfield(str,'compcd') && isfield(str,'compf')
          ptden = str.compcd.ptden;
          den = str.compf.den;
          nsp = length(den) + length(ptden)-1;
          trend = ones(1,nsp)*2;
          nc = length(Z) - (nsp+ns+nr);
          cycle = ones(1,nc)*3;
      else
          trend = []; cycle = [];
      end
      
     
      compall = [trendcycle trend cycle seas tran];
      Z = str.Z;
      
   end

   lcomp = length(comp);
   c = zeros(lcomp,length(compall));
 
   for i = 1:lcomp
       d = eval(comp{i});
       k = find(d(1) == compall);
       l = Z(k);
       c(i,k:k+length(d)-1) = l;
   end
   c = logical(c);
   
end


[Ystar,t1] = bootsam(y,X,Z,G,W,T,H,ins,ii,beta,nboot);  
[ly,p,junk] = size(Ystar);

% Adjust the number of system matrices if t1 > 1
if t1 > 1 
 [mx, nx]=size(X);
 [mz, nalpha]=size(Z);
 [mg, neps]=size(G);
 [mw, nw]=size(W);
 [mt, nt]=size(T);
 [mh, nh]=size(H);
 if mx > p 
  X=X((t1-1)*p+1:end,:);
  [Q,R,Indx,ierror] = housref(X);
  for i=1:nx
   if Indx(i) == 1
    X(:,i)=[];
   end
  end
 end
 if mz > p 
  Z=Z((t1-1)*p+1:end,:);
 end
 if mg > p 
  G=G((t1-1)*p+1:end,:);
 end
 if mw > nalpha 
  W=W((t1-1)*nalpha+1:end,:);
  [Q,R,Indx,ierror] = housref(W);
  for i=1:nw
   if Indx(i) == 1
    W(:,i)=[];
   end
  end
 end
 if mt > nalpha 
  T=T((t1-1)*nalpha+1:end,:);
 end
 if mh > nalpha
  H=H((t1-1)*nalpha+1:end,:);
 end
end

if islogical(comp)
    Compstar = zeros(ly,sum(comp),nboot);
else Compstar = zeros(ly,lcomp,nboot);
end

for j = 1:nboot 
 % Compute estimated (smoothed) state vector using the boostrap sample
 [KKP]=scakfs(Ystar(:,:,j),X,Z,G,W,T,H,ins,ii); 
 % Smoothed selected components
 if islogical(comp)  
    Compstar(:,:,j) = KKP(:,comp);
 else 
     for i = 1:lcomp
         ci = c(i,:);
         comp = sum(KKP(:,ci),2);
         Compstar(:,i,j) = comp;
     end
 end
end
